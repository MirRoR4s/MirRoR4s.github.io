<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 建涛的博客</title>
    <link>http://localhost:1313/posts/</link>
    <description>Recent content in Posts on 建涛的博客</description>
    <generator>Hugo -- 0.140.2</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 05 Jan 2025 16:32:29 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Cs61b Lec34</title>
      <link>http://localhost:1313/posts/cs61b-lec34/</link>
      <pubDate>Sun, 05 Jan 2025 16:32:29 +0800</pubDate>
      <guid>http://localhost:1313/posts/cs61b-lec34/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本节课程讲述的内容如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快排作者Tony Hoare提出的&lt;a href=&#34;https://docs.google.com/presentation/d/1WbLTQcGvN0BTbAytdbsONtLLlVlbftE229YKgrW5Ge8/edit#slide=id.g12b16f43a3_0_5&#34;&gt;分区算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一个更加聪明的&lt;a href=&#34;https://docs.google.com/presentation/d/1WbLTQcGvN0BTbAytdbsONtLLlVlbftE229YKgrW5Ge8/edit#slide=id.g1d76fccf63_0_55&#34;&gt;Pivot选择策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;排序算法的稳定性、可适应性以及一些优化策略&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>Cs61b Lec33</title>
      <link>http://localhost:1313/posts/cs61b-lec33/</link>
      <pubDate>Sun, 05 Jan 2025 15:15:17 +0800</pubDate>
      <guid>http://localhost:1313/posts/cs61b-lec33/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;本节课程讲述的内容如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快速排序（quicksort）算法的起源&lt;/li&gt;
&lt;li&gt;快速排序算法描述&lt;/li&gt;
&lt;li&gt;快速排序算法性能&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;起源httpsdocsgooglecompresentationd19cbz7ou-_b5y0btyo1ifiaeqcn0digccz49cmo9_hy4editslideidg9816be120_1_370&#34;&gt;&lt;a href=&#34;https://docs.google.com/presentation/d/19CbZ7oU-_b5y0Btyo1IfIAEqcn0DIgcCz49cMO9_hy4/edit#slide=id.g9816be120_1_370&#34;&gt;起源&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;快速排序算法（以下简称快排）是一个名为 Tony Hoare 的人提出的。他当时在开发一个将英文翻译为俄文的程序，具体的实现思路是在遇见一个英文单词时利用二分查找算法在字典中查找该英文单词对应的俄文单词并进行相应的替换。&lt;/p&gt;
&lt;p&gt;在理想的情况下，如果字典的长度是D，那么执行一次二分查找的时间复杂度是$\Theta(logD)$，所以将N个英文单词翻译为对应俄文单词的时间复杂度就为$\Theta(NlogD)$（执行N次二分查找）。然而现实并没有这么理想，因为字典信息存储在磁带上，所以从后面的单词跳到前面的单词就需要移动磁带，这会花费一定的时间，所以执行二分查找的时间复杂度并不是$O(logD)$。解决这个问题的办法就是让磁带不会来回移动而是一直往后走，实现该目标的措施就是事先排序英文句子，所以Tone Hoare就需要找到一个能够排序英文句子的算法，这就引出了快排。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;算法描述&#34;&gt;算法描述&lt;/h2&gt;
&lt;p&gt;快排的核心是一个称为&lt;a href=&#34;https://docs.google.com/presentation/d/19CbZ7oU-_b5y0Btyo1IfIAEqcn0DIgcCz49cMO9_hy4/edit#slide=id.g4661758db_113&#34;&gt;分区&lt;/a&gt;（partition）的操作，分区指的是选中数组的某个元素（这个被选中的元素成为pivot），经过一些步骤使得pivot左边的元素都小于等于pivot，而pivot右边的元素都大于等于pivot（这个过程中pivot在数组中的位置可能会也可能不会改变）。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;alt text&#34; loading=&#34;lazy&#34; src=&#34;../../static/img/cs61b-lec33/image.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;alt text&#34; loading=&#34;lazy&#34; src=&#34;../../static/cs61b-lec33/image-1.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;课后习题&#34;&gt;课后习题&lt;/h2&gt;
&lt;p&gt;问：找到快排一个最坏情况下的输入（假设总选择最左边的元素作为pivot）&lt;/p&gt;
&lt;p&gt;答：最坏情况出现在pivot分区后总落在数组的第一个位置，这种情况对应的输入可以是 [1, 2, 3, 4, 5]&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;问：快排在最好、最坏、平均情况下的递归深度是多少？&lt;/p&gt;
&lt;p&gt;答：&lt;strong&gt;分区的次数和递归深度相等&lt;/strong&gt;，假设总选择最左边的元素作为pivot，那么：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最好情况：最好情况下会进行$O(log^n)$次分区，所以最好情况下的递归深度是$O(log^n)$&lt;/li&gt;
&lt;li&gt;最坏情况：最坏情况下会进行N次分区，所以最坏情况下的递归深度是$O(n)$&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.google.com/presentation/d/19CbZ7oU-_b5y0Btyo1IfIAEqcn0DIgcCz49cMO9_hy4/edit#slide=id.g4661758db_1583&#34;&gt;平均情况&lt;/a&gt;：$O(log^n)$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;问：假设采用的分区策略是将元素分为3类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;小于pivot&lt;/li&gt;
&lt;li&gt;等于pivot&lt;/li&gt;
&lt;li&gt;大于pivot&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设该分区策略的运行时间是$\Theta(N)$，证明一个快排对一个长为N但仅有7个不同元素的数组的运行时间是$\Theta(N)$。（比如[0, 1, 0, 0, 6, 6, 5, 5, 4, 2, 2, 0, 3, 0, 1, …, 2, 6]）&lt;/p&gt;
&lt;p&gt;以 [0, 1, 0, 0, 6, 6, 5, 5, 4, 2, 2, 0, 3, 0, 1, 2, 6] 为例根据题目的分区策略进行快排：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Cs61b Lec32</title>
      <link>http://localhost:1313/posts/cs61b-lec32/</link>
      <pubDate>Thu, 02 Jan 2025 20:17:41 +0800</pubDate>
      <guid>http://localhost:1313/posts/cs61b-lec32/</guid>
      <description>&lt;h2 id=&#34;recommend-problems&#34;&gt;Recommend problems&lt;/h2&gt;
&lt;h3 id=&#34;b-level&#34;&gt;B Level&lt;/h3&gt;
&lt;p&gt;问题1：找出插入排序的一个最好情况下的输入和一个最坏情况下的输入&lt;/p&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最好情况：[1, 2, 3] （任意有序的数组都可充当最好情况下的输入）&lt;/li&gt;
&lt;li&gt;最坏情况：[3, 2, 1]，&lt;a href=&#34;https://docs.google.com/presentation/d/1sVYr8F5Emh573vqDxefWJQzh1zYylIjjeyeXPy7Md2s/edit#slide=id.g12a12f5ae1_0_48&#34;&gt;guide&lt;/a&gt;提到如果序列有k个inversion，那么最坏情况下插入一个元素的成本是k&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问题2：对于一个逆序的数组，插入排序和选择排序谁运行得更快？&lt;/p&gt;
&lt;p&gt;答案：选择排序运行地更快&lt;/p&gt;</description>
    </item>
    <item>
      <title>CS61B lec4</title>
      <link>http://localhost:1313/posts/cs61b-lec4/</link>
      <pubDate>Tue, 31 Dec 2024 23:26:57 +0800</pubDate>
      <guid>http://localhost:1313/posts/cs61b-lec4/</guid>
      <description>&lt;h1 id=&#34;guide&#34;&gt;guide&lt;/h1&gt;
&lt;h2 id=&#34;c-level&#34;&gt;C Level&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;待定。&lt;/li&gt;
&lt;li&gt;解释什么是哨兵节点以及为什么哨兵节点很重要。如果代码没有哨兵节点会出错吗？IntList必须有哨兵节点吗？&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>First Post</title>
      <link>http://localhost:1313/posts/first-post/</link>
      <pubDate>Tue, 31 Dec 2024 23:02:27 +0800</pubDate>
      <guid>http://localhost:1313/posts/first-post/</guid>
      <description>&lt;p&gt;首次利用hugo搭建个人博客。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
